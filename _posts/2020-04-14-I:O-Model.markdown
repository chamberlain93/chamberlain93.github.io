---
layout:     post
title:      "Linux中I/O的几种类型"
subtitle:   "I/O延续进程生命"
date:       2020-04-14 22:00:00
author:     "Chamberlain"
header-img: "img/post-bg-io.png"
catalog: true
tags:
    - Linux
    - I/O
---

> "穷且益坚 不坠青云之志"



##  前言

计算机的I/O是一个比较抽象的概念，看不见摸不着，但他又是实际存在的，并且在计算机改变世界的过程中发挥了至关重要的作用。***巧妇难为无米之炊***这句话来形容I/O的作用最合适不过了，再🐂的家庭煮夫没有米也做不出香喷喷的米饭，米饭从无到有需要经历一个漫长的过程，播种、护理、收割…，所以我又要说，大部分情况下应用程序处理问题的大部分时间其实都是花在I/O上，所以处理好I/O对于提高应用程序的性能尤为重要。言归正传，I/O分为两个阶段，一个阶段是**准备数据阶段**，比如从磁盘中读取数据，从网络流中读取数据，从键盘鼠标等外设中读取数据；另一个阶段是将数据从**操作系统内核的缓冲区中拷贝到用户程序的内存地址**中。这里就涉及到了应用程序的内核态和用户态，简而言之就是进程在操作系统中执行的两种状态，内核态用于执行系统调用，用户态用于执行应用程序自身逻辑。这两个阶段目前产生了五种I/O的模式：

> * **阻塞I/O**：准备数据和拷贝数据都阻塞
> * **非阻塞I/O**：准备数据不阻塞，拷贝数据阻塞
> * **I/O多路复用**：准备数据不阻塞，拷贝数据阻塞，但是可以处理多个链接
> * **信号驱动I/O**：准备数据不阻塞，拷贝数据阻塞
> * **异步I/O**：准备数据阶段和拷贝数据阶段均不阻塞



## 正文

### 阻塞I/O

阻塞I/O的两个阶段应用程序都是阻塞的，当应用程序调用系统调用recvfrom时，操作系统内核会进入数据准备阶段，获取从磁盘网络等外部传输进来的数据，数据准备完毕后，操作系统内核再将数据从内核缓冲区拷贝到用户的内存空间，在这两个过程中，用户程序时被阻塞，什么也干不了。举个简单的例子，服装店和工厂，当服装店的衣服买完了，服装店老板需要通知工厂生产新的服装，然后再把服装运输回来买，这个过程老板首先要去工厂守着，等他们8⃣把服装生产完毕后，在开车运输回来，在这个过程，服装店老板什么也干不了，只能在工厂干等着，等生产完毕在把服装运回来卖。这个场景就是典型的阻塞I/O，工厂生产服装相当于数据准备阶段，运输服装相当于数据拷贝阶段。下图是典型的阻塞I/O流程：

![preview](/img/in-post/blocking-IO.png)

#### 非阻塞I/O

非阻塞I/O相对于第一步做了一步处理，就是在数据准备阶段不再阻塞，而是通过不断询问的方式确认数据有没有准备好，如果准备好了就将数据拷贝到用户内存空间。回到刚才的例子，意思就是说服装店老板会定时打电话问工厂老板服装有没有生产好，如果生产好了就去工厂运输。这里要注意的是，虽然数据准备阶段不是阻塞的，但是数据准备阶段依然是阻塞的，因此这种I/O依然是同步的。下图是典型的非阻塞I/O流程：

![preview](/img/in-post/NONblocking-IO.png)

#### I/O多路复用

I/O多路复用是前两个I/O模式的加强版，大致意思就是通过一个进程管理多个I/O通道，管理方式时轮询加通知，在linux中是通过select，poll，epoll这三个函数区完成这个操作的，当多个I/O中的任何一个通道有数据时，这个负责管理的进程就会通知用户程序拷贝数据，处理数据。再回到刚才那个例子，服装店生意做大了后，货源不在来源于一个工厂，如此下来，店长肯定忙不过来，于是雇佣了一个人去工厂帮他守着或者帮他打电话，当店员得知某一个工厂服装生产好了以后，就会通知店长去运输服装，特别要注意的是，在这个I/O模式下，拷贝数据阶段依然是阻塞的，店长还需要亲自去运输。实质上select、poll、epoll这三个函数干了一件事，就是当数据准备阶段完成后，通知用户进程去拷贝数据，相比上两种I/O模式，这三个函数另外一大优点就是可以处理多个I/O。如下图，是典型的I/O多路复用流程：

![preview](/img/in-post/IO-multiplex.png)

#### 信号驱动I/O

信号驱动I/O也是非阻塞的，当在数据准备阶段时，如果数据准备好了，会使用信号的方式通知用户程序去执行拷贝数据的系统调用。回到刚才的例子，信号驱动与非阻塞的区别在于信息获取的方式，信号驱动相当于店长雇佣一个人去工厂守着，当服装准备好了后，会及时通知店长去运输，而非阻塞需要店长不断打电话去询问。从效率上来说，信号驱动I/O更高。

#### 异步I/O

I/O的两个阶段都是来源于recvfrom这个系统调用，也就是说只要这两个阶段有一个阶段阻塞了用户进程，我们就认为这个I/O过程是同步的，以上三种I/O模式的第二个阶段都是阻塞的，因此以上三种I/O都是同步的。异步的I/O意思就是两个阶段都不能阻塞用户进程，回到刚才那个例子，异步I/O与nonblocking-I/O只有一个区别，就是当店长发现工厂服装生产好了后，他会雇佣一个人去帮他运输服装或者工厂送货上门，这样一来，自己就不用阻塞在运输服装这个环节。下图是AIO的流程：

![preview](/img/in-post/AIO.png)



## 后记

总结一下，阻塞与非阻塞的区别在于系统调用是不是会及时返回，同步I/O与异步I/O的区别在于I/O的两个阶段是不是都是非阻塞的。